<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>IFE JavaScript Task 01</title>
  </head>
<body>

  <label>请输入北京今天空气质量：<input id="aqi-input" type="text"></label>
  <button id="button">确认填写</button>

  <div>您输入的值是：<span id="aqi-display">尚无录入</span></div>

<script type="text/javascript">

(function() {
  var button = document.getElementById('button')
  button.addEventListener("click", function(){
    var display = document.getElementById('aqi-display')
    // console.log(document.getElementById('aqi-input').value)
    display.innerText = document.getElementById('aqi-input').value
    display.textContent = document.getElementById('aqi-input').value
    // 两种方法更改text，以下摘自mdn
    // textContent与innerText的区别
    // Internet Explorer 引入了 element.innerText，目的是相似的，不过有下面几点不同之处：

    // textContent 会获取所有元素的内容，包括<script> 和 <style> 元素，然而 IE 专有属性 innerText 不会。
    // innerText 会受样式的影响，它不返回隐藏元素的文本，但 textContent 返回。
    // 由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但textContent 不会。
    // 与 textContent 不同的是, 在 Internet Explorer (对于小于等于 IE11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会永久性地销毁所有内部文本节点（由此导致无法再将这些被销毁的文本节点插入到当前元素或任何其他元素中）。
    // textContent与innerHTML的区别

    // 正如它的名字，innerHTML 返回 HTML 文本。很多时候，当需要往一个元素里面写文本的时候，人们使用 innerHTML，但其实应该使用 textContent，因为文本不会被解析为 HTML，所以它很可能在性能表现上会更好，同时还能够避免XSS攻击。
    
  })

})();

</script>
</body>
</html>